name: Deploy to VPS

on:
  push:
    branches: [main]
  workflow_dispatch:

concurrency:
  group: deploy-main
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-24.04
    env:
      TZ: Europe/Rome
      VPS_HOST: ${{ secrets.VPS_HOST }}
      VPS_USER: ${{ secrets.VPS_USER }}
      VPS_APP_DIR: ${{ secrets.VPS_APP_DIR }}
      VPS_SSH_KEY: ${{ secrets.VPS_SSH_KEY }}
      APP_ENV_FILE: ${{ secrets.APP_ENV_FILE }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Preflight: verify required keys exist in APP_ENV_FILE
      - name: Preflight .env keys presence
        run: |
          set -euo pipefail

          if [ -z "${APP_ENV_FILE:-}" ]; then
            echo "APP_ENV_FILE secret is empty or not provided" >&2
            exit 1
          fi

          required=(
            # Core
            DATABASE_URL
            JWT_SECRET
            BASE_URL

            # Sirplay inbound (Sirplay -> Kasyrooms)
            SIRPLAY_WEBHOOK_SECRET
            SIRPLAY_CUSTOMER_ID
            SIRPLAY_PARTNER_ID

            # B2B basic auth (Sirplay -> Kasyrooms)
            B2B_BASIC_AUTH_USER
            B2B_BASIC_AUTH_PASS

            # Sirplay outbound (Kasyrooms -> Sirplay)
            SIRPLAY_API_URL
            SIRPLAY_ACCESS_USER
            SIRPLAY_ACCESS_PASS
          )

          missing=0
          for k in "${required[@]}"; do
            if printf "%s\n" "$APP_ENV_FILE" | grep -Eq "^[[:space:]]*$k[[:space:]]*="; then
              echo "OK $k"
            else
              echo "MISSING $k" >&2
              missing=1
            fi
          done

          # Optional check: SIRPLAY_WALLET_PASSPORT key existence (may be empty). Warn only.
          if printf "%s\n" "$APP_ENV_FILE" | grep -Eq "^[[:space:]]*SIRPLAY_WALLET_PASSPORT[[:space:]]*="; then
            echo "OK SIRPLAY_WALLET_PASSPORT (may be empty)"
          else
            echo "WARN missing SIRPLAY_WALLET_PASSPORT key"
          fi

          test $missing -eq 0

      # Sync repository to VPS
      - name: Rsync repository to VPS
        uses: burnett01/rsync-deployments@5.2
        with:
          switches: -avz --delete --exclude '.git' --exclude 'node_modules'
          path: .
          remote_path: ${{ env.VPS_APP_DIR }}/
          remote_host: ${{ env.VPS_HOST }}
          remote_user: ${{ env.VPS_USER }}
          remote_key: ${{ env.VPS_SSH_KEY }}

      # Write .env on VPS from APP_ENV_FILE
      - name: Write .env on VPS (from APP_ENV_FILE secret)
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ env.VPS_HOST }}
          username: ${{ env.VPS_USER }}
          key: ${{ env.VPS_SSH_KEY }}
          script: |
            set -e
            set -x
            : "ssh step start"
            mkdir -p "${{ env.VPS_APP_DIR }}"
            cat > "${{ env.VPS_APP_DIR }}/.env" <<'EOF__APP_ENV'
            ${{ env.APP_ENV_FILE }}
            EOF__APP_ENV
            chmod 600 "${{ env.VPS_APP_DIR }}/.env"

      - name: Verify B2B creds present on VPS .env
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ env.VPS_HOST }}
          username: ${{ env.VPS_USER }}
          key: ${{ env.VPS_SSH_KEY }}
          script: |
            set -e
            set -x
            : "ssh step start"
            cd "${{ env.VPS_APP_DIR }}"
            echo "Checking B2B credentials in .env..."
            grep -nE '^(B2B_BASIC_AUTH_USER|B2B_BASIC_AUTH_PASS|SIRPLAY_B2B_USER|SIRPLAY_B2B_PASSWORD)=' .env | cat -A || {
              echo "Missing B2B credentials in .env" >&2
              exit 1
            }

      # Install deps, build, prune, reload PM2
      - name: Install deps, build on VPS, prune and reload PM2
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ env.VPS_HOST }}
          username: ${{ env.VPS_USER }}
          key: ${{ env.VPS_SSH_KEY }}
          script: |
            set -e
            set -x
            : "ssh step start"
            cd "${{ env.VPS_APP_DIR }}"

            # Export DATABASE_URL for non-app commands (drizzle-kit, etc.).
            # Avoid `source .env` because DATABASE_URL may contain shell-special chars (e.g. &).
            DATABASE_URL="$(grep -E '^DATABASE_URL=' .env | head -n1 | cut -d= -f2-)"
            # trim CRLF + optional surrounding quotes
            DATABASE_URL="${DATABASE_URL%$'\r'}"
            DATABASE_URL="${DATABASE_URL#\"}"
            DATABASE_URL="${DATABASE_URL%\"}"
            export DATABASE_URL

            # Node 20 via nvm (if present)
            if [ -s "$HOME/.nvm/nvm.sh" ]; then . "$HOME/.nvm/nvm.sh"; fi
            if command -v nvm >/dev/null 2>&1; then
              nvm install 20 >/dev/null
              nvm use 20
            fi
            node -v

            # deps + build + prune (runtime only)
            npm ci --include=dev --no-audit --no-fund

            # Production: do NOT run drizzle-kit push (it would also try to create legacy local-auth tables).
            # Instead, ensure only the Sirplay production tables exist.
            npm run db:ensure:sirplay

            npm run build
            npm prune --omit=dev --no-audit --no-fund

            # PM2
            command -v pm2 >/dev/null 2>&1 || npm i -g pm2
            if [ -f pm2.config.cjs ]; then
              pm2 reload pm2.config.cjs --only kasyrooms --env production --update-env || pm2 start pm2.config.cjs
            elif [ -f ecosystem.config.cjs ]; then
              pm2 reload ecosystem.config.cjs --only kasyrooms --env production --update-env || pm2 start ecosystem.config.cjs
            else
              pm2 restart all || true
            fi
            pm2 save || true

      - name: Local smoke checks on VPS (127.0.0.1:5000)
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ env.VPS_HOST }}
          username: ${{ env.VPS_USER }}
          key: ${{ env.VPS_SSH_KEY }}
          script: |
            set -euo pipefail
            set -x
            : "ssh step start"
            cd "${{ env.VPS_APP_DIR }}"

            base_url="http://127.0.0.1:5000"

            # Ensure single instance to avoid PM2 cluster memory divergence during local smoke
            pm2 scale kasyrooms 1 || true
            pm2 reload ecosystem.config.cjs --only kasyrooms --env production --update-env || pm2 reload kasyrooms --update-env || true

            # Local healthz with retry (avoid flakiness right after PM2 reload)
            echo "[Local Smoke] healthz at $base_url/api/healthz"
            attempts=5
            delay=2
            ok=0
            last_status=""
            last_body=""
            for i in $(seq 1 $attempts); do
              tmp="$(mktemp)"
              status="$(curl -sS -o "$tmp" -w '%{http_code}' "$base_url/api/healthz" || echo "000")"
              body="$(cat "$tmp" 2>/dev/null || true)"
              rm -f "$tmp"
              last_status="$status"
              last_body="$body"

              if [ "$status" = "200" ]; then
                ok=1
                break
              fi
              echo "Healthz not ready (attempt $i/$attempts): $status"
              sleep "$delay"
            done

            if [ "$ok" -ne 1 ]; then
              echo "Healthz FAILED: HTTP $last_status" >&2
              echo "-- response (truncated) --"
              printf '%s' "$last_body" | head -c 2048
              echo
              exit 1
            fi
            echo "Healthz OK (200)"

            # B2B no-auth should be 401 and never 500
            echo "[Local Smoke] b2b login-tokens without Authorization (expect 401, never 500)"
            tmp="$(mktemp)"
            status="$(curl -sS -o "$tmp" -w '%{http_code}' -X POST "$base_url/api/b2b/login-tokens" \
              -H 'Content-Type: application/json' \
              -d '{"externalId":"SMOKE-NOAUTH-001"}' || echo "000")"
            body="$(cat "$tmp" 2>/dev/null || true)"
            rm -f "$tmp"

            if [ -z "$status" ] || [ "$status" = "000" ] || ! printf '%s' "$status" | grep -Eq '^[0-9]{3}$'; then
              echo "B2B no-auth CONNECTION ERROR or invalid status: $status" >&2
              echo "-- response (truncated) --"
              printf '%s' "$body" | head -c 2048
              echo
              exit 1
            fi

            if [ "$status" -eq 500 ]; then
              echo "B2B no-auth REGRESSION: got 500" >&2
              echo "-- response (truncated) --"
              printf '%s' "$body" | head -c 2048
              echo
              exit 1
            fi

            if [ "$status" -ne 401 ]; then
              echo "B2B no-auth FAILED: expected 401, got $status" >&2
              echo "-- response (truncated) --"
              printf '%s' "$body" | head -c 2048
              echo
              exit 1
            fi
            echo "B2B no-auth OK (401)"

            # Invalid JSON should be 400
            echo "[Local Smoke] b2b invalid JSON should be 400"
            tmp="$(mktemp)"
            status="$(curl -sS -o "$tmp" -w '%{http_code}' -X POST "$base_url/api/b2b/login-tokens" \
              -H 'Content-Type: application/json' \
              -d '{' || echo "000")"
            body="$(cat "$tmp" 2>/dev/null || true)"
            rm -f "$tmp"

            if [ -z "$status" ] || [ "$status" = "000" ] || ! printf '%s' "$status" | grep -Eq '^[0-9]{3}$'; then
              echo "B2B invalid-json CONNECTION ERROR or invalid status: $status" >&2
              echo "-- response (truncated) --"
              printf '%s' "$body" | head -c 2048
              echo
              exit 1
            fi

            if [ "$status" -ne 400 ]; then
              echo "B2B invalid-json FAILED: expected 400, got $status" >&2
              echo "-- response (truncated) --"
              printf '%s' "$body" | head -c 2048
              echo
              exit 1
            fi
            echo "B2B invalid-json OK (400)"

            # Build Basic header from .env credentials (required by registrations endpoint)
            u="$(grep -E '^(B2B_BASIC_AUTH_USER|SIRPLAY_B2B_USER)=' .env | tail -n1 | cut -d= -f2-)"
            p="$(grep -E '^(B2B_BASIC_AUTH_PASS|SIRPLAY_B2B_PASSWORD)=' .env | tail -n1 | cut -d= -f2-)"
            BASIC="$(printf '%s' "$u:$p" | base64 | tr -d '\n')"

            echo "[Local Smoke] seeding test user via Sirplay handshake"
            # This is the Sirplay-side id (their user identifier) used only to seed your DB via /api/sirplay/login
            SIRPLAY_USER_ID="SIRPLAY-SMOKE-001"

            tmp="$(mktemp)"
            HANDSHAKE_STATUS="$(curl -sS -o "$tmp" -w '%{http_code}' -X POST "$base_url/api/sirplay/login" \
              -H "Content-Type: application/json" \
              -d "{\"externalUserId\":\"$SIRPLAY_USER_ID\",\"email\":\"smoke-$SIRPLAY_USER_ID@sirplay.com\",\"username\":\"smokeuser\"}" || echo "000")"
            HANDSHAKE_JSON="$(cat "$tmp" 2>/dev/null || true)"
            rm -f "$tmp"

            if [ "$HANDSHAKE_STATUS" != "200" ]; then
              echo "Handshake FAILED: expected 200 got $HANDSHAKE_STATUS" >&2
              echo "-- response (truncated) --"; printf '%s' "$HANDSHAKE_JSON" | head -c 2048; echo
              exit 1
            fi

            HANDSHAKE_TOKEN="$(node -e "const o=JSON.parse(process.argv[1]); if(!o.token) process.exit(2); process.stdout.write(o.token);" "$HANDSHAKE_JSON")"
            echo "Seed OK (token captured)"

            echo "[Local Smoke] register inbound to persist mapping (Basic Auth)"
            # Sirplay -> Kasyrooms registration event (request contains Sirplay userId; response returns internal Kasyrooms userId)
            REG_STATUS="$(curl -sS -o /tmp/reg.json -w "%{http_code}" \
              -X POST "$base_url/user-account/signup/b2b/registrations" \
              -H "Content-Type: application/json" \
              -H "Authorization: Basic $BASIC" \
              -d "{
                \"eventId\":\"smoke-001\",
                \"customerId\":\"572\",
                \"operation\":\"REGISTER\",
                \"action\":\"USER_REGISTRATION\",
                \"eventTime\": $(date +%s%3N),
                \"userData\": {
                  \"userId\":\"$SIRPLAY_USER_ID\",\
                  \"customerId\":\"572\",
                  \"status\":\"ACTIVE\",
                  \"profileType\":\"PLAYER\",
                  \"userName\":\"smokeuser\",
                  \"password\":\"Secret123!\",
                  \"name\":\"Smoke\",
                  \"surname\":\"Test\",
                  \"email\":\"smoke-$SIRPLAY_USER_ID@sirplay.com\"
                }
              }")"

            cat /tmp/reg.json || true

            if [ "$REG_STATUS" != "201" ] && [ "$REG_STATUS" != "200" ]; then
              echo "REGISTER FAILED: expected 200/201 got $REG_STATUS"
              exit 1
            fi
            echo "Register OK ($REG_STATUS)"

            # Extract internal Kasyrooms userId from registration response
            KASY_USER_ID="$(node -e "const o=require('/tmp/reg.json'); const id=o?.userData?.userId; if(!id){process.exit(2)} process.stdout.write(String(id))")"
            echo "Resolved KASY_USER_ID=$KASY_USER_ID"

            # Optional: Sirplay externalId may be present; log it but don't fail if missing
            SIRPLAY_EXTERNAL_ID="$(node -e "const o=require('/tmp/reg.json'); const id=o?.userData?.externalId; if(!id){process.exit(0)} process.stdout.write(String(id))" || true)"
            echo "Resolved SIRPLAY_EXTERNAL_ID=${SIRPLAY_EXTERNAL_ID:-<empty>}"

            echo "[Local Smoke] verify mapping via getUserInfo (by Sirplay userId)"
            tmp="$(mktemp)"
            INFO_STATUS="$(curl -sS -o "$tmp" -w '%{http_code}' \
              -H "Authorization: Basic $BASIC" \
              "$base_url/api/user/getUserInfo?externalUserId=$SIRPLAY_USER_ID" || echo "000")"
            INFO_BODY="$(cat "$tmp" 2>/dev/null || true)"
            rm -f "$tmp"
            if [ "$INFO_STATUS" != "200" ]; then
              echo "getUserInfo FAILED: expected 200 got $INFO_STATUS" >&2
              echo "-- response (truncated) --"; printf '%s' "$INFO_BODY" | head -c 2048; echo
              exit 1
            fi
            echo "getUserInfo OK (200)"

            echo "[Local Smoke] b2b login-tokens (auth-positive) using internal Kasyrooms userId"
            TOK_STATUS="$(curl -sS -o /tmp/tok.json -w "%{http_code}" \
              -X POST "$base_url/api/b2b/login-tokens" \
              -H "Content-Type: application/json" \
              -H "Authorization: Basic $BASIC" \
              -d "{\"externalId\":\"$KASY_USER_ID\"}")"

            cat /tmp/tok.json || true

            if [ "$TOK_STATUS" != "200" ]; then
              echo "B2B auth-positive FAILED: expected 200 got $TOK_STATUS"
              exit 1
            fi
            echo "B2B auth-positive OK (200)"

      # Smoke check (public, via Cloudflare)
      - name: Smoke check /api/healthz (with retries)
        run: |
          set -e
          url="https://dev.kasyrooms.com/api/healthz"
          attempts=10
          delay=3
          for i in $(seq 1 $attempts); do
            if curl -fsS -L "$url" >/dev/null; then
              echo "Health check OK on attempt $i"
              exit 0
            fi
            echo "Health check failed (attempt $i/$attempts). Waiting ${delay}s..."
            sleep $delay
          done
          echo "Health check failed after $attempts attempts"
          curl -v "$url" || true
          exit 1
